//|-----------------------------------------------------------------------------------------|
//|                                                           ForexGrowthBot_v18_SqLite.mq4 |
//|                                                            Copyright © 2011, Dennis Lee |
//| Assert History                                                                          |
//| 1.3.2   Added PlusTD to replace previous support functions for TDSetup indicator.       |
//| 1.3.1   Replace function isSetGlobalVar() with GlobalVariableCheck() in function init().|
//|            If ANY of the FOUR (4) global vars do not exist, then set UseWave1TDSetup=F. |
//| 1.3.0   Added functions isOkWave1Buy() and isOkWave1Sell() to indicate if qualifier     |
//|            ONE (1) allows trade to open. Qualifier 1 has EIGHT (8) parameters: FOUR (4) |
//|            for Do Not BUY condition, and FOUR (4) for Do Not SELL condition.            |
//|            For example, to trade a BUY only if UP line is broken (DN line irrelevant):  |
//|               DoNotBuyUp=1 (UP is intact) and DoNotBuyDn=0 (irrelevant).                |
//|            Conversely, to trade a SELL only if DN line is broken (UP line irrelevant):  |
//|               DoNotSellUp=0 (irrelevant) and DoNotSellDn=1 (DN is intact).              |
//|         Added functions LoadGlobalVars() and isSetGlobalVar().                          |
//| 1.2.0   Added qualifier ONE (1), checks that TDST UpLine has been broken before opening |
//|            a LONG trade. Conversely, checks that TDST DnLine has been broken before     |
//|            opening a SHORT trade. This reduces the likelihood that the market reverses  |
//|            after a volatility breakout.                                                 |
//| 1.11    Calculate and display TP on chart. Fixed missing include files.                 |
//| 1.10    Incorporated PlusGhost changes from ForexGrowthBot_v16_SqLite 1.20.             |
//| 1.00    Generated by EX4 TO MQ4 decompile service.                                      |
//|-----------------------------------------------------------------------------------------|
#property copyright "Copyright © 2011, Dennis Lee"
#property link      ""

#include <WinUser32.mqh>
#import "fxgrbot.dll"
   int initQuant(int a0, int a1, int a2, double a3, double a4, double a5, int a6, int a7, double a8, int a9, string a10);
   double GetVolatilityRatio(double& a0[], double& a1[], int a2, int a3, int a4, int a5);
   int GetQuantPositionChange(int a0, int a1, int a2, int a3, double a4, int a5, int a6, double a7, double a8, double a9, double a10, double a11);
   int getSlotCount(int a0, int a1);
   int SetPipsTrailSettings(int a0, double a1, double a2, double a3, int a4);
   int GetLicenseState(int a0);
   int getSystemID();
#import

//--- Assert 2: Plus include files
extern string     s1                         = "-->PlusTD Settings<--";
#include <PlusTD.mqh>
extern string     s2                         = "-->PlusTurtle Settings<--";
#include <PlusTurtle.mqh>
extern string     s3                         = "-->PlusGhost Settings<--";
#include <PlusGhost.mqh>
extern string     e1                         = "Debug Properties";
extern bool       EaViewDebugNotify          = false;
extern int        EaViewDebug                = 0;
extern int        EaViewDebugNoStack         = 1000;
extern int        EaViewDebugNoStackEnd      = 10;

//|-----------------------------------------------------------------------------------------|
//|                           E X T E R N A L   V A R I A B L E S                           |
//|-----------------------------------------------------------------------------------------|
int SysId = -100;
bool gi_80 = TRUE;
string gs_84 = " Basic 1.8 ";
extern double     LotSize                    = 0.1;
extern int        Magic                      = 456976;
extern int        AccountNo                  = 404803;
extern bool       FIFO                       = FALSE;
extern int        ClosePreviousSessionOrders = 2;
extern bool       Assign_PT_and_ST           = FALSE;
extern bool       InternalControl            = TRUE;
extern bool       ManualTradeControl         = FALSE;
int gi_124 = 99;
string g_comment_128 = "Forex Growth Bot";
extern int        FastVolatilityBase         = 5;
extern int        SlowVolatilityBase         = 60;
extern double     VolatilityFactor           = 2.0;
double gd_152 = 0.5;
double gd_160 = 0.2;
int gi_168 = 50;
extern bool       SmartExit = TRUE;
string EaName = "ForexGrowthBot_v18_SqLite";
string EaVer = "1.3.2";
//|-----------------------------------------------------------------------------------------|
//|                           I N T E R N A L   V A R I A B L E S                           |
//|-----------------------------------------------------------------------------------------|
bool gi_176 = FALSE;
int gi_180 = 0;
int gi_184 = 0;
bool gi_188 = FALSE;
string gs_192 = "40-80;40-80;40-80;40";
int gi_200 = 18;
double gd_204 = 0.65;
double gd_212 = 0.0;
bool gi_unused_220 = FALSE;
int gi_224 = 25;
int gi_228 = 0;
int gi_232 = 0;
int gi_236 = 1;
bool gi_unused_240 = TRUE;
int g_datetime_244;
int gi_252 = 0;
double gd_256 = 1.0;
double gd_264 = 0.0;
int gi_unused_272 = -1000;
double gd_unused_276 = 0.0;
double gd_unused_284 = 0.0;
double gd_unused_292 = 0.0;
int gi_unused_300 = 0;
bool gi_unused_304 = FALSE;
double gd_308 = 100000.0;
double gd_316 = 250.0;
int gi_324 = 240;
int g_timeframe_328 = PERIOD_M15;
double gd_332 = 10.0;
bool gi_340 = TRUE;
bool gi_unused_344 = TRUE;
int gi_348 = 30;
int gi_352 = 5000;
bool gi_356 = TRUE;
int gi_360 = 0;
int gi_364 = 10000;
int g_fontsize_368 = 7;
string gs_tahoma_372 = "Tahoma";
bool gi_380 = TRUE;
int g_color_384 = White;
int LicStatus = 0;
int g_x_392 = 4;
int g_y_396 = 27;
double gd_400 = 0.0;
double gd_unused_408 = 0.0;
int gi_416 = 0;
int gi_420 = 0;
int g_datetime_424 = 0;
int gi_unused_428 = 5;
double gd_unused_432 = 3.0;

//|-----------------------------------------------------------------------------------------|
//|                           I N T E R N A L   F U N C T I O N S                           |
//|-----------------------------------------------------------------------------------------|
void UpdateState(string as_0) {
   if (InternalControl && (!ManualTradeControl) && (!Assign_PT_and_ST)) {
      ObjectDelete("fgbPosInfo" + gi_416);
      ObjectCreate("fgbPosInfo" + gi_416, OBJ_LABEL, 0, 0, 0);
      ObjectSetText("fgbPosInfo" + gi_416, "ForexGrowthBot PosState: " + as_0, g_fontsize_368, gs_tahoma_372, g_color_384);
      ObjectSet("fgbPosInfo" + gi_416, OBJPROP_CORNER, 0);
      ObjectSet("fgbPosInfo" + gi_416, OBJPROP_XDISTANCE, g_x_392);
      ObjectSet("fgbPosInfo" + gi_416, OBJPROP_YDISTANCE, g_y_396);
   }
}
double getPosSize() {
   double ld_0 = 0;
//--- Assert 2: Init OrderSelect #1
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   int total=GhostOrdersTotal();
   for (int pos_8 = 0; pos_8 < total; pos_8++) {
      if (GhostOrderSelect(pos_8, SELECT_BY_POS, MODE_TRADES) == FALSE) {
         Print("SELECT ERROR");
         break;
      }
      if (GhostOrderMagicNumber() != Magic || GhostOrderSymbol() != Symbol()) continue;
      if (GhostOrderType() == OP_BUY) ld_0 += GhostOrderLots();
      if (GhostOrderType() == OP_SELL) ld_0 -= GhostOrderLots();
   }
//--- Assert 1: Free OrderSelect #1   
   GhostFreeSelect(true);
   return (NormalizeDouble(ld_0, 2));
}

double normPrice(double ad_0) {
   return (NormalizeDouble(ad_0, Digits));
}

double RoundPrec(double ad_0, double ad_8) {
   return (MathRound(ad_0 / ad_8) * ad_8);
}

void WaitDLLCall() {
   if (!GlobalVariableCheck("TMSEC")) GlobalVariableSet("TMSEC", TimeSeconds(TimeCurrent()));
   if (!IsTesting()) {
      while (MathAbs(TimeSeconds(TimeCurrent()) - GlobalVariableGet("TMSEC")) == 0.0) {
         Sleep(250);
         RefreshRates();
      }
      GlobalVariableSet("TMSEC", TimeSeconds(TimeCurrent()));
   }
}

void LockInitCall() {
   if (!GlobalVariableCheck("FXLockInitCall")) GlobalVariableSet("FXLockInitCall", 0);
   if (!IsTesting()) {
      while (GlobalVariableGet("FXLockInitCall") == 1.0) {
         Sleep(250);
         RefreshRates();
      }
      GlobalVariableSet("FXLockInitCall", 1);
   }
}

void UnLockInitCall() {
   if (!GlobalVariableCheck("FXLockInitCall")) GlobalVariableSet("FXLockInitCall", 0);
   if (!IsTesting()) {
      GlobalVariableSet("FXLockInitCall", 0);
      RefreshRates();
   }
}

void WaitUntilContex() {
   if (!IsTesting()) {
      while (IsTradeContextBusy() == TRUE) {
         Sleep(100);
         RefreshRates();
      }
   }
}

int CareCloseOrder(int a_ticket_0, int ai_4, double a_lots_8) {
   bool li_ret_16 = FALSE;
   color color_20 = CLR_NONE;
   int count_24 = 0;
   int error_28 = 0;
   double price_32 = 0;
   RefreshRates();
   if (ai_4 == 0) {
      price_32 = normPrice(Bid);
      color_20 = Green;
   } else {
      price_32 = normPrice(Ask);
      color_20 = Red;
   }
   bool is_closed_40 = FALSE;
   if (IsTesting()) GhostOrderClose(a_ticket_0, a_lots_8, price_32, 50, color_20);
   else {
      for (count_24 = 0; count_24 < gi_348; count_24++) {
         WaitUntilContex();
         is_closed_40 = GhostOrderClose(a_ticket_0, a_lots_8, price_32, 50, color_20);
         error_28 = 0;
         if (!is_closed_40) error_28 = GetLastError();
         if (!is_closed_40) {
            Sleep(gi_352);
            RefreshRates();
            if (ai_4 == 0) {
               price_32 = normPrice(Bid);
               continue;
            }
            price_32 = normPrice(Ask);
         } else {
            li_ret_16 = TRUE;
            break;
         }
      }
   }
   return (li_ret_16);
}

void AdjustPosition(int ai_0) {
   double minlot_4 = MarketInfo(Symbol(), MODE_MINLOT);
   double ld_12 = RoundPrec(ai_0 * LotSize * gd_256, minlot_4);
   ld_12 = NormalizeDouble(ld_12, 2);
   double ld_unused_20 = 0;
   int count_28 = 0;
   int li_unused_32 = 0;
   int ticket_36 = 0;
//--- Assert 7: Declare variables for OrderSelect #2
//       1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aCommand[];    
   int      aTicket[];
   double   aLots[];
   double   aClosePrice[];
   bool     aOk;
   int      aCount;
   int      total;
   int      maxTrades=10;
//--- Assert 4: Dynamically resize arrays
   ArrayResize(aCommand,maxTrades);
   ArrayResize(aTicket,maxTrades);
   ArrayResize(aLots,maxTrades);
   ArrayResize(aClosePrice,maxTrades);
   if (FIFO) {
   //--- Assert 2: Init OrderSelect #2 with arrays
      GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
      total=GhostOrdersTotal();
      for (int pos_40 = 0; pos_40 < total; pos_40++) {
         if (GhostOrderSelect(pos_40, SELECT_BY_POS, MODE_TRADES) == FALSE) {
            Print("SELECT ERROR");
            break;
         }
      //--- Assert 4: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aLots[aCount]        =  GhostOrderLots();
         aClosePrice[aCount]  =  GhostOrderClosePrice();
         if (GhostOrderMagicNumber() != Magic || GhostOrderSymbol() != Symbol()) continue;
         if (GhostOrderType() == OP_BUY && ld_12 < 0.0) {
            if (GhostOrderLots() <= MathAbs(ld_12)) {
               ld_12 += GhostOrderLots();
               ld_12 = NormalizeDouble(ld_12, 2);
            //--- Assert 3: replace CareCloseOrder a buy trade with arrays
               aCommand[aCount]     = 2;
               aCount ++;
               if( aCount >= maxTrades ) break;
               /*CareCloseOrder(OrderTicket(), 0, OrderLots());*/
               pos_40--;
            } else {
               if (GhostOrderLots() > MathAbs(ld_12) && MathAbs(ld_12) != 0.0) {
               //--- Assert 4: replace CareCloseOrder a buy trade with arrays
                  aCommand[aCount]     = 2;
                  aLots[aCount]        = MathAbs(ld_12);
                  aCount ++;
                  if( aCount >= maxTrades ) break;
                  /*CareCloseOrder(OrderTicket(), 0, MathAbs(ld_12));*/
                  ld_12 = 0;
                  pos_40--;
               }
            }
         }
         if (GhostOrderType() == OP_SELL && ld_12 > 0.0) {
            if (GhostOrderLots() <= MathAbs(ld_12)) {
               ld_12 -= GhostOrderLots();
               ld_12 = NormalizeDouble(ld_12, 2);
            //--- Assert 3: replace CareCloseOrder a sell trade with arrays
               aCommand[aCount]     = 4;
               aCount ++;
               if( aCount >= maxTrades ) break;
               /*CareCloseOrder(OrderTicket(), 1, OrderLots());*/
               pos_40--;
               continue;
            }
            if (GhostOrderLots() > MathAbs(ld_12) && MathAbs(ld_12) != 0.0) {
            //--- Assert 4: replace CareCloseOrder a sell trade with arrays
               aCommand[aCount]     = 4;
               aLots[aCount]        = MathAbs(ld_12);
               aCount ++;
               if( aCount >= maxTrades ) break;
               /*CareCloseOrder(OrderTicket(), 1, MathAbs(ld_12));*/
               ld_12 = 0;
               pos_40--;
            }
         }
      }
   //--- Assert 1: Free OrderSelect #2
      GhostFreeSelect(false);
   //--- Assert for: process array of commands
      for(int i=0; i<aCount; i++)
      {
         switch( aCommand[i] )
         {
            case 2:  // CareCloseOrder Buy
               CareCloseOrder(aTicket[i], 0, aLots[i]);
               break;
            case 4:  // CareCloseOrder Sell
               CareCloseOrder(aTicket[i], 1, aLots[i]);
               break;
         }
      }
   } else {
   //--- Assert 2: Init OrderSelect #3 with arrays
      GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
      total=GhostOrdersTotal();
       for (pos_40 = total - 1; pos_40 >= 0; pos_40--) {
         if (GhostOrderSelect(pos_40, SELECT_BY_POS, MODE_TRADES) == FALSE) {
            Print("SELECT ERROR");
            break;
         }
      //--- Assert 4: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aLots[aCount]        =  GhostOrderLots();
         aClosePrice[aCount]  =  GhostOrderClosePrice();
         if (GhostOrderMagicNumber() != Magic || GhostOrderSymbol() != Symbol()) continue;
         if (GhostOrderType() == OP_BUY && ld_12 < 0.0) {
            if (GhostOrderLots() <= MathAbs(ld_12)) {
               ld_12 += GhostOrderLots();
               ld_12 = NormalizeDouble(ld_12, 2);
            //--- Assert 3: replace CareCloseOrder a buy trade with arrays
               aCommand[aCount]     = 2;
               aCount ++;
               if( aCount >= maxTrades ) break;
               /*CareCloseOrder(OrderTicket(), 0, OrderLots());*/
            } else {
               if (GhostOrderLots() > MathAbs(ld_12) && MathAbs(ld_12) != 0.0) {
               //--- Assert 4: replace CareCloseOrder a buy trade with arrays
                  aCommand[aCount]     = 2;
                  aLots[aCount]        = MathAbs(ld_12);
                  aCount ++;
                  if( aCount >= maxTrades ) break;
                  /*CareCloseOrder(OrderTicket(), 0, MathAbs(ld_12));*/
                  ld_12 = 0;
               }
            }
         }
         if (GhostOrderType() == OP_SELL && ld_12 > 0.0) {
            if (GhostOrderLots() <= MathAbs(ld_12)) {
               ld_12 -= GhostOrderLots();
               ld_12 = NormalizeDouble(ld_12, 2);
            //--- Assert 3: replace CareCloseOrder a sell trade with arrays
               aCommand[aCount]     = 4;
               aCount ++;
               if( aCount >= maxTrades ) break;
               /*CareCloseOrder(OrderTicket(), 1, OrderLots());*/
               continue;
            }
            if (GhostOrderLots() > MathAbs(ld_12) && MathAbs(ld_12) != 0.0) {
            //--- Assert 4: replace CareCloseOrder a sell trade with arrays
               aCommand[aCount]     = 4;
               aLots[aCount]        = MathAbs(ld_12);
               aCount ++;
               if( aCount >= maxTrades ) break;
               /*CareCloseOrder(OrderTicket(), 1, MathAbs(ld_12));*/
               ld_12 = 0;
            }
         }
      }
   //--- Assert 1: Free OrderSelect #3
      GhostFreeSelect(false);
   //--- Assert for: process array of commands
      for(i=0; i<aCount; i++)
      {
         switch( aCommand[i] )
         {
            case 2:  // CareCloseOrder Buy
               CareCloseOrder(aTicket[i], 0, aLots[i]);
               break;
            case 4:  // CareCloseOrder Sell
               CareCloseOrder(aTicket[i], 1, aLots[i]);
               break;
         }
      }
   }
   ld_12 = NormalizeDouble(ld_12, 2);
   if (ld_12 > 0.0) {
      if (IsTesting()) GhostOrderSend(Symbol(), OP_BUY, MathAbs(ld_12), normPrice(Ask), 25, 0, 0, g_comment_128, Magic, 0, Green);
      else {
         WaitUntilContex();
         for (count_28 = 0; count_28 < gi_348; count_28++)
         {
         //--- Assert check for qualifier 1 (when line is broken, it is ok to trade)
            if( TDWave1Buy() )
               ticket_36 = GhostOrderSend(Symbol(), OP_BUY, MathAbs(ld_12), normPrice(Ask), 25, 0, 0, g_comment_128, Magic, 0, Green);
            if (ticket_36 > 0)
            {
               EaDebugPrint( 0, "AdjustPosition",
                  EaDebugStr("EaName", EaName)+
                  EaDebugStr("EaVer", EaVer)+
                  EaDebugStr("sym", Symbol())+
                  EaDebugInt("mgc", Magic)+
                  EaDebugInt("ticket", ticket_36)+
                  EaDebugInt("type", OP_BUY)+
                  EaDebugDbl("lot", MathAbs(ld_12))+
                  EaDebugDbl("openPrice", normPrice(Ask))+
                  TDDebugGlobal()+
                  EaDebugBln("TDWave1Buy",true) );
               break;
            }
            Sleep(gi_352);
            RefreshRates();
         }
      }
   }
   if (ld_12 < 0.0) {
      if (IsTesting()) GhostOrderSend(Symbol(), OP_SELL, MathAbs(ld_12), normPrice(Bid), 25, 0, 0, g_comment_128, Magic, 0, Red);
      else {
         WaitUntilContex();
         for (count_28 = 0; count_28 < gi_348; count_28++)
         {
         //--- Assert check for qualifier 1 (when line is broken, it is ok to trade)
            if( TDWave1Sell() )
               ticket_36 = GhostOrderSend(Symbol(), OP_SELL, MathAbs(ld_12), normPrice(Bid), 25, 0, 0, g_comment_128, Magic, 0, Red);
            if (ticket_36 > 0) 
            {
               EaDebugPrint( 0, "AdjustPosition",
                  EaDebugStr("EaName", EaName)+
                  EaDebugStr("EaVer", EaVer)+
                  EaDebugStr("sym", Symbol())+
                  EaDebugInt("mgc", Magic)+
                  EaDebugInt("ticket", ticket_36)+
                  EaDebugInt("type", OP_SELL)+
                  EaDebugDbl("lot", MathAbs(ld_12))+
                  EaDebugDbl("openPrice", normPrice(Bid))+
                  TDDebugGlobal()+
                  EaDebugBln("TDWave1Sell",true) );
               break;
            }
            Sleep(gi_352);
            RefreshRates();
         }
      }
   }
   if (gd_264 == 0.0) gd_264 = AccountEquity();
   if (ld_12 == 0.0 && gi_176 && getSlotCount(SysId, 0) == 0) {
      if (AccountEquity() - gd_264 > 1500.0 && AccountEquity() - gd_264 < 3500.0) {
         LotSize += 0.05;
         gd_264 = AccountEquity();
      }
      if (AccountEquity() - gd_264 > 3500.0) {
         LotSize += 0.1;
         gd_264 = AccountEquity();
      }
   }
}

void postInit() {
   bool li_0;
   int li_unused_4;
   if (gi_356) {
      gi_356 = FALSE;
      MathSrand(TimeLocal());
      Sleep(5.0 * (1000.0 * (MathRand() + 0.0000001) / 32767.0));
      if (IsTesting()) SysId = 0;
      else SysId = getSystemID();
      gi_340 = TRUE;
      gd_264 = 0;
      gi_360 = 0;
      if (gd_212 != 0.0) {
         gd_212 = MathAbs(gd_212);
         if (!gi_188) {
            gs_192 = gd_212;
            gi_188 = TRUE;
         }
      }
      li_0 = FALSE;
      if (gi_188) li_0 = TRUE;
      li_unused_4 = 0;
      if (SysId < 0) li_unused_4 = 0;
      else
         if (SysId > 100) li_unused_4 = 99;
      g_timeframe_328 = Period();
      WaitDLLCall();
      LockInitCall();
      initQuant(AccountNo, SysId, gd_332, gd_152, gd_160, gd_316, gi_324, g_timeframe_328, gd_308, li_0, gs_192);
      UnLockInitCall();
      g_datetime_244 = iTime(NULL, Period(), 0);
      gi_252 = 0;
      gd_unused_284 = LotSize;
   }
}
//|-----------------------------------------------------------------------------------------|
//|                             I N I T I A L I Z A T I O N                                 |
//|-----------------------------------------------------------------------------------------|
int init() {
   bool li_16;
   int li_unused_20;
   double ld_24;
   double minlot_0 = MarketInfo(Symbol(), MODE_MINLOT);
   double lotstep_8 = MarketInfo(Symbol(), MODE_LOTSTEP);
   gi_80 = TRUE;
   if (LotSize < minlot_0) gi_80 = FALSE;
   if (NormalizeDouble(LotSize, 2) != NormalizeDouble(RoundPrec(LotSize, lotstep_8), 2)) gi_80 = FALSE;
   if (gi_124 < 1) gi_124 = 1;
   gi_416 = MathRand();
   gi_420 = 1974;
   gi_380 = TRUE;
   LicStatus = 0;
   gd_400 = 0;
   gd_unused_408 = 0;
   g_datetime_424 = 0;
   
//--- Assert 3: Init Plus mods   
   TDInit();
   TurtleInit();
   GhostInit();
   
   if (gi_380) {
      ObjectDelete("fgbLicenseInfo" + gi_420);
      ObjectCreate("fgbLicenseInfo" + gi_420, OBJ_LABEL, 0, 0, 0);
      ObjectSetText("fgbLicenseInfo" + gi_420, "ForexGrowthBot" + gs_84 + "license status: VERIFYING", g_fontsize_368, gs_tahoma_372, g_color_384);
      ObjectSet("fgbLicenseInfo" + gi_420, OBJPROP_CORNER, 0);
      ObjectSet("fgbLicenseInfo" + gi_420, OBJPROP_XDISTANCE, g_x_392);
      ObjectSet("fgbLicenseInfo" + gi_420, OBJPROP_YDISTANCE, 15);
      gi_380 = FALSE;
   }
   if (InternalControl && (!ManualTradeControl) && (!Assign_PT_and_ST)) {
      ObjectDelete("fgbPosInfo" + gi_416);
      ObjectCreate("fgbPosInfo" + gi_416, OBJ_LABEL, 0, 0, 0);
      ObjectSetText("fgbPosInfo" + gi_416, "ForexGrowthBot Position: Internal = 0.00, External = 0.00", g_fontsize_368, gs_tahoma_372, g_color_384);
      ObjectSet("fgbPosInfo" + gi_416, OBJPROP_CORNER, 0);
      ObjectSet("fgbPosInfo" + gi_416, OBJPROP_XDISTANCE, g_x_392);
      ObjectSet("fgbPosInfo" + gi_416, OBJPROP_YDISTANCE, g_y_396);
   }
   if (!SmartExit) gi_200 = FALSE;
   if (!gi_356) {
      MathSrand(TimeLocal());
      Sleep(5.0 * (1000.0 * (MathRand() + 0.0000001) / 32767.0));
      if (IsTesting()) SysId = 0;
      else SysId = getSystemID();
      gi_340 = TRUE;
      gd_264 = 0;
      gi_360 = 0;
      if (gd_212 != 0.0) {
         gd_212 = MathAbs(gd_212);
         if (!gi_188) {
            gs_192 = gd_212;
            gi_188 = TRUE;
         }
      }
      li_16 = FALSE;
      if (gi_188) li_16 = TRUE;
      li_unused_20 = 0;
      if (SysId < 0) li_unused_20 = 0;
      else
         if (SysId > 100) li_unused_20 = 99;
      g_timeframe_328 = Period();
      WaitDLLCall();
      LockInitCall();
      initQuant(AccountNo, SysId, gd_332, gd_152, gd_160, gd_316, gi_324, g_timeframe_328, gd_308, li_16, gs_192);
      UnLockInitCall();
      g_datetime_244 = iTime(NULL, Period(), 0);
      gi_252 = 0;
      gd_unused_284 = LotSize;
   }
   if (!gi_80) {
      ObjectDelete("fgbPosInfo" + gi_416);
      ObjectCreate("fgbPosInfo" + gi_416, OBJ_LABEL, 0, 0, 0);
      ObjectSetText("fgbPosInfo" + gi_416, "ForexGrowthBot: Incorrect LotSize! EA disabled.", g_fontsize_368, gs_tahoma_372, Red);
      ObjectSet("fgbPosInfo" + gi_416, OBJPROP_CORNER, 0);
      ObjectSet("fgbPosInfo" + gi_416, OBJPROP_XDISTANCE, g_x_392);
      ObjectSet("fgbPosInfo" + gi_416, OBJPROP_YDISTANCE, g_y_396);
      ld_24 = RoundPrec(LotSize, lotstep_8);
      if (LotSize < minlot_0) Alert("Forex Growth Bot: Incorrect Lot Size, LotSize is less than Minimum Lot Allowed. Robot OFF, please change LotSize, then restart MT4.");
      else
         if (NormalizeDouble(LotSize, 2) != NormalizeDouble(RoundPrec(LotSize, lotstep_8), 2)) Alert("Forex Growth Bot:  Incorrect LotSize, LotSize should be " + DoubleToStr(ld_24, 2) + ", Robot OFF, please change LotSize, then restart MT4.");
   }
   return (0);
}
//|-----------------------------------------------------------------------------------------|
//|                             D E I N I T I A L I Z A T I O N                             |
//|-----------------------------------------------------------------------------------------|
int deinit() {
   ObjectDelete("fgbLicenseInfo" + gi_420);
   ObjectDelete("fgbPosInfo" + gi_416);
//--- Assert 1: Deinit Plus mods
   GhostDeInit();
   return (0);
}
//|-----------------------------------------------------------------------------------------|
//|                               M A I N   P R O C E D U R E                               |
//|-----------------------------------------------------------------------------------------|
int start() {
   string text_0;
   bool is_closed_12;
   bool li_20;
   bool li_24;
   int mb_code_32;
   int error_36;
   int li_48;
   string text_52;
   double ld_60;
   int li_unused_68;
   double PriceClose[];
   double PriceOpen[];
   double ld_80;
   int li_92;
   double VolRatio;
   double ld_104;
   double ld_112;
   double ld_120;
   double ld_128;
   double ld_136;
   double ld_144;
   int li_152;
   double ld_156;
   double price_164;
   bool li_172;
   if (!gi_80) return (0);
   if (LicStatus == 0) {
      if (GetLicenseState(AccountNo) != 0) {
         LicStatus = GetLicenseState(AccountNo);
         text_0 = "";
         if (LicStatus == 1) text_0 = "ForexGrowthBot" + gs_84 + "license status: ACTIVE";
         if (LicStatus == 2) text_0 = "ForexGrowthBot" + gs_84 + "license status: NOT ACTIVE! ACTIVATE AN ACCOUNT, PLEASE!";
         if (LicStatus > 0) {
            ObjectDelete("fgbLicenseInfo" + gi_420);
            ObjectCreate("fgbLicenseInfo" + gi_420, OBJ_LABEL, 0, 0, 0);
            ObjectSetText("fgbLicenseInfo" + gi_420, text_0, g_fontsize_368, gs_tahoma_372, g_color_384);
            ObjectSet("fgbLicenseInfo" + gi_420, OBJPROP_CORNER, 0);
            ObjectSet("fgbLicenseInfo" + gi_420, OBJPROP_XDISTANCE, g_x_392);
            ObjectSet("fgbLicenseInfo" + gi_420, OBJPROP_YDISTANCE, 15);
         }
      }
   }
   postInit();
   int count_8 = 0;
   
//--- Assert 7: Declare variables for OrderSelect #4
//       1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aCommand[];    
   int      aTicket[];
   double   aLots[];
   double   aClosePrice[];
   bool     aOk;
   int      aCount;
   int      total;
   int      maxTrades=10;
//--- Assert 4: Dynamically resize arrays
   ArrayResize(aCommand,maxTrades);
   ArrayResize(aTicket,maxTrades);
   ArrayResize(aLots,maxTrades);
   ArrayResize(aClosePrice,maxTrades);
   if (gi_340 && (!IsTesting())) {
      gi_340 = FALSE;
      if (ClosePreviousSessionOrders <= 0) return (0);
      is_closed_12 = TRUE;
      li_20 = FALSE;
      li_24 = TRUE;
      if (ClosePreviousSessionOrders > 1) {
         li_20 = TRUE;
         li_24 = TRUE;
      }
      WaitUntilContex();
   //--- Assert 2: Init OrderSelect #4 with arrays
      GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
      total=GhostOrdersTotal();
      for (int pos_28 = 0; pos_28 <= total; pos_28++) {
         if (GhostOrderSelect(pos_28, SELECT_BY_POS, MODE_TRADES) == FALSE) break;
      //--- Assert 4: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aLots[aCount]        =  GhostOrderLots();
         aClosePrice[aCount]  =  GhostOrderClosePrice();
         if (GhostOrderMagicNumber() != Magic || GhostOrderSymbol() != Symbol()) continue;
         if (!li_20) {
            li_20 = TRUE;
            mb_code_32 = MessageBox("Trades operated by Forex Growth Bot are still open.  We recommend closing them as they will not be tracked by the robot after MT4 has restart.",
               "Forex Growth Bot", MB_YESNO|MB_ICONQUESTION);
            if (mb_code_32 == IDNO) li_24 = FALSE;
         }
         for (count_8 = 0; count_8 < gi_348; count_8++) {
            RefreshRates();
            if (GhostOrderType() == OP_BUY && li_24) {
               WaitUntilContex();
            //--- Assert 4: replace OrderClose a buy trade with arrays
               aCommand[aCount]     = 2;
               aCount ++;
               if( aCount >= maxTrades ) break;
               is_closed_12 = true;
               /*is_closed_12 = OrderClose(OrderTicket(), OrderLots(), Bid, 10, Green);*/
            }
            if (GhostOrderType() == OP_SELL && li_24) {
               WaitUntilContex();
            //--- Assert 4: replace OrderClose a sell trade with arrays
               aCommand[aCount]     = 4;
               aCount ++;
               if( aCount >= maxTrades ) break;
               is_closed_12 = true;
               /*is_closed_12 = OrderClose(OrderTicket(), OrderLots(), Ask, 10, Red);*/
            }
            error_36 = GetLastError();
            if (!is_closed_12) {
               Sleep(gi_352);
               RefreshRates();
            } else {
               pos_28--;
               break;
            }
         }
      }
   //--- Assert 1: Free OrderSelect #4
      GhostFreeSelect(false);
   //--- Assert for: process array of commands
      for(int i=0; i<aCount; i++)
      {
         switch( aCommand[i] )
         {
            case 2:  // CareCloseOrder Buy
               GhostOrderClose(aTicket[i], aLots[i], Bid, 10, Green);
               break;
            case 4:  // CareCloseOrder Sell
               GhostOrderClose(aTicket[i], aLots[i], Ask, 10, Red);
               break;
         }
      }
      return (0);
   }
   int timeframe_40 = Period();
   pos_28 = 0;
   int ticket_44 = 0;
   if (iTime(NULL, Period(), 0) - g_datetime_244 >= timeframe_40) {
      li_48 = GetLicenseState(AccountNo);
      text_52 = "";
      if (li_48 == 1) text_52 = "ForexGrowthBot" + gs_84 + "license status: ACTIVE";
      if (li_48 == 2) text_52 = "ForexGrowthBot" + gs_84 + "license status: NOT ACTIVE! ACTIVATE AN ACCOUNT, PLEASE!";
      if (li_48 > 0) {
         ObjectDelete("fgbLicenseInfo" + gi_420);
         ObjectCreate("fgbLicenseInfo" + gi_420, OBJ_LABEL, 0, 0, 0);
         ObjectSetText("fgbLicenseInfo" + gi_420, text_52, g_fontsize_368, gs_tahoma_372, g_color_384);
         ObjectSet("fgbLicenseInfo" + gi_420, OBJPROP_CORNER, 0);
         ObjectSet("fgbLicenseInfo" + gi_420, OBJPROP_XDISTANCE, g_x_392);
         ObjectSet("fgbLicenseInfo" + gi_420, OBJPROP_YDISTANCE, 15);
      }
      gi_252 += Period();
      ld_60 = 0;
      for (ld_60 = gi_228; ld_60 <= gi_232; ld_60++) {
         li_unused_68 = 0;
         for (pos_28 = 0; pos_28 < gi_236; pos_28++) {
            if (ArraySize(Close) > 101) {
               ArrayCopy(PriceClose, Close, 0, 1, 100);
               ArrayCopy(PriceOpen, Open, 0, 1, 100);
               ld_80 = 0;
               if (ld_60 > 0.0) {
                  for (int index_88 = 0; index_88 < ArraySize(PriceClose); index_88++) {
                     if (MathRand() > 16383) ld_80 = (MathRand() + 0.0000001) / 32767.0 * (ld_60 * Point);
                     else ld_80 = (-(MathRand() + 0.0000001)) / 32767.0 * (ld_60 * Point);
                     PriceClose[index_88] += ld_80;
                  }
                  for (index_88 = 0; index_88 < ArraySize(PriceOpen); index_88++) {
                     if (MathRand() > 16383) ld_80 = (MathRand() + 0.0000001) / 32767.0 * (ld_60 * Point);
                     else ld_80 = (-(MathRand() + 0.0000001)) / 32767.0 * (ld_60 * Point);
                     PriceOpen[index_88] += ld_80;
                  }
               }
            }
            li_92 = 0;
            VolRatio = 0;
            g_datetime_244 = iTime(NULL, Period(), 0);
            if (ArraySize(Close) > 101) {
               WaitDLLCall();
               VolRatio = GetVolatilityRatio(PriceClose, PriceOpen, FastVolatilityBase, SlowVolatilityBase, 100, AccountNo);
               if (MathAbs(VolRatio) >= VolatilityFactor) {
                  if (VolRatio > 0.0) li_92 = 1;
                  else li_92 = -1;
                  gi_360 += li_92;
                  if (MathAbs(gi_360) > gi_364) {
                     gi_360 = gi_364 * (gi_360 / MathAbs(gi_360));
                     li_92 = 0;
                  }
               }
            }
            ld_104 = gd_152;
            ld_112 = gd_160;
            ld_120 = High[iHighest(NULL, 0, MODE_HIGH, gi_168, 1)] - Low[iLowest(NULL, 0, MODE_LOW, gi_168, 1)];
            ld_120 *= gd_308;
            if ((!Assign_PT_and_ST) || ManualTradeControl) {
               ld_128 = 1.0 * (gi_180 + 0.0) / MathPow(10, Digits);
               ld_136 = 1.0 * (gi_184 + 0.0) / MathPow(10, Digits);
               ld_144 = 0;
               WaitDLLCall();
               SetPipsTrailSettings(SysId, ld_128, ld_136, ld_144, gi_124);
               li_152 = GetQuantPositionChange(AccountNo, SysId, 0, gi_224, PriceClose[0], li_92, gi_252, ld_104, ld_112, ld_120, gi_200, gd_204);
               gi_360 += li_152;
               gd_400 += NormalizeDouble(li_152 * LotSize, 2);
               if (li_152 != 0) {
                  UpdateState("Updating");
                  AdjustPosition(li_152);
                  g_datetime_424 = TimeCurrent();
               }
            } else {
               ld_156 = High[iHighest(NULL, 0, MODE_HIGH, gi_168, 1)] - Low[iLowest(NULL, 0, MODE_LOW, gi_168, 1)];
               price_164 = 0;
               if (li_92 == 1) {
                  price_164 = normPrice(Ask);
                  if (IsTesting()) {
                     ticket_44 = GhostOrderSend(Symbol(), OP_BUY, LotSize, price_164, 25, 0, 0, g_comment_128, Magic, 0, Green);
                     GhostOrderModify(ticket_44, price_164, price_164 - NormalizeDouble(ld_156 * gd_160, Digits), price_164 + NormalizeDouble(ld_156 * gd_152, Digits), 0, Green);
                  } else {
                     WaitUntilContex();
                     for (count_8 = 0; count_8 < gi_348; count_8++)
                     {
                     //--- Assert check for qualifier 1 (when line is broken, it is ok to trade)
                        if( TDWave1Buy()  )
                           ticket_44 = GhostOrderSend(Symbol(), OP_BUY, LotSize, price_164, 25, 0, 0, g_comment_128, Magic, 0, Green);
                        if (ticket_44 > 0)
                        {
                           EaDebugPrint( 0, "start",
                              EaDebugStr("EaName", EaName)+
                              EaDebugStr("EaVer", EaVer)+
                              EaDebugStr("sym", Symbol())+
                              EaDebugInt("mgc", Magic)+
                              EaDebugInt("ticket", ticket_44)+
                              EaDebugInt("type", OP_BUY)+
                              EaDebugDbl("lot", LotSize)+
                              EaDebugDbl("openPrice", price_164)+
                              TDDebugGlobal()+
                              EaDebugBln("TDWave1Buy",true) );
                           break;
                        }
                        Sleep(gi_352);
                        RefreshRates();
                        price_164 = normPrice(Ask);
                     }
                     if (ticket_44 >= 0 && (!ManualTradeControl)) {
                        for (count_8 = 0; count_8 < gi_348; count_8++) {
                           if (!(!GhostOrderModify(ticket_44, price_164, normPrice(price_164) - NormalizeDouble(ld_156 * gd_160, Digits), normPrice(price_164) + NormalizeDouble(ld_156 * gd_152, Digits), 0,
                              Green))) break;
                           Sleep(gi_352);
                           RefreshRates();
                        }
                     }
                  }
               }
               if (li_92 == -1) {
                  price_164 = normPrice(Bid);
                  if (IsTesting()) {
                     ticket_44 = GhostOrderSend(Symbol(), OP_SELL, LotSize, price_164, 25, 0, 0, g_comment_128, Magic, 0, Red);
                     GhostOrderModify(ticket_44, price_164, price_164 + NormalizeDouble(ld_156 * gd_160, Digits), price_164 - NormalizeDouble(ld_156 * gd_152, Digits), 0, Red);
                     continue;
                  }
                  count_8 = 0;
                  WaitUntilContex();
                  while (count_8 < gi_348) 
                  {
                  //--- Assert check for qualifier 1 (when line is broken, it is ok to trade)
                     if( TDWave1Sell() )
                        ticket_44 = GhostOrderSend(Symbol(), OP_SELL, LotSize, price_164, 100, 0, 0, g_comment_128, Magic, 0, Red);
                     if (ticket_44 > 0) 
                     {
                        EaDebugPrint( 0, "start",
                           EaDebugStr("EaName", EaName)+
                           EaDebugStr("EaVer", EaVer)+
                           EaDebugStr("sym", Symbol())+
                           EaDebugInt("mgc", Magic)+
                           EaDebugInt("ticket", ticket_44)+
                           EaDebugInt("type", OP_SELL)+
                           EaDebugDbl("lot", LotSize)+
                           EaDebugDbl("openPrice", price_164)+
                           TDDebugGlobal()+
                           EaDebugBln("TDWave1Sell",true) );
                        break;
                     }
                     Sleep(gi_352);
                     RefreshRates();
                     price_164 = normPrice(Bid);
                     count_8++;
                  }
                  if (ticket_44 >= 0 && (!ManualTradeControl)) {
                     for (count_8 = 0; count_8 < gi_348; count_8++) {
                        if (!(!GhostOrderModify(ticket_44, price_164, normPrice(price_164) + NormalizeDouble(ld_156 * gd_160, Digits), normPrice(price_164) - NormalizeDouble(ld_156 * gd_152, Digits), 0,
                           Red))) break;
                        Sleep(gi_352);
                        RefreshRates();
                     }
                  }
               }
            }
         }
      }
   } else {
      if ((!ManualTradeControl) && !Assign_PT_and_ST && gi_184 > 0 || gi_180 > 0) {
         ld_104 = gd_152;
         ld_112 = gd_160;
         ld_120 = High[iHighest(NULL, 0, MODE_HIGH, gi_168, 1)] - Low[iLowest(NULL, 0, MODE_LOW, gi_168, 1)];
         ld_120 *= gd_308;
         ld_136 = 1.0 * (gi_184 + 0.0) / MathPow(10, Digits);
         ld_128 = 1.0 * (gi_180 + 0.0) / MathPow(10, Digits);
         WaitDLLCall();
         li_172 = FALSE;
         ld_144 = 1;
         WaitDLLCall();
         SetPipsTrailSettings(SysId, ld_128, ld_136, ld_144, gi_124);
         li_152 = GetQuantPositionChange(AccountNo, SysId, 0, gi_224, normPrice(Close[0]), li_172, gi_252, ld_104, ld_112, ld_120, gi_200, gd_204);
         gd_400 += NormalizeDouble(li_152 * LotSize, 2);
         gi_360 += li_152;
         if (li_152 != 0) {
            UpdateState("Updating");
            AdjustPosition(li_152);
            g_datetime_424 = TimeCurrent();
         }
      }
   }
//--- Assert calculate and display TP
   double posSize = getPosSize();
   double posTP;
   string strTP;
   if( posSize!=0 )
   {
      if( ld_156!=0 && price_164!=0 && gd_152!=0 )
      {
      //--- Assert Buy positions opened
         if( posSize>0 ) posTP = normPrice(price_164) + NormalizeDouble(ld_156 * gd_152, Digits);
      //--- Assert Sell positions opened
         if( posSize<0 ) posTP = normPrice(price_164) - NormalizeDouble(ld_156 * gd_152, Digits);
         strTP = "    posTP=" + DoubleToStr(posTP,5) + "\n";
      }
      else
         strTP = "    posTP=0  (ld_156=" + DoubleToStr(ld_156,5) + "  price_164=" + DoubleToStr(price_164,5) + "  gd_152=" + DoubleToStr(price_164,5) + ")\n";
   }
//--- Assert Refresh Plus mods
   GhostRefresh();
   Comment( EaComment("\n\n\n"+strTP) );
   
   if (TimeCurrent() - g_datetime_424 >= 30 || MathAbs(NormalizeDouble(getPosSize(), 2) - NormalizeDouble(gd_400, 2)) < LotSize && InternalControl && (!ManualTradeControl) &&
      (!Assign_PT_and_ST)) {
      if (MathAbs(NormalizeDouble(getPosSize(), 2) - NormalizeDouble(gd_400, 2)) < LotSize) {
         ObjectDelete("fgbPosInfo" + gi_416);
         ObjectCreate("fgbPosInfo" + gi_416, OBJ_LABEL, 0, 0, 0);
         ObjectSetText("fgbPosInfo" + gi_416, "ForexGrowthBot Position: Internal = " + DoubleToStr(NormalizeDouble(getPosSize(), 2), 2) + ", External = " + DoubleToStr(NormalizeDouble(gd_400,
            2), 2), g_fontsize_368, gs_tahoma_372, g_color_384);
         ObjectSet("fgbPosInfo" + gi_416, OBJPROP_CORNER, 0);
         ObjectSet("fgbPosInfo" + gi_416, OBJPROP_XDISTANCE, g_x_392);
         ObjectSet("fgbPosInfo" + gi_416, OBJPROP_YDISTANCE, g_y_396);
      }
      if (MathAbs(NormalizeDouble(getPosSize(), 2) - NormalizeDouble(gd_400, 2)) >= LotSize && TimeCurrent() - g_datetime_424 >= 30) {
         AdjustPosition(NormalizeDouble((NormalizeDouble(gd_400, 2) - NormalizeDouble(getPosSize(), 2)) / LotSize, 2));
         UpdateState("Updating");
      }
   }
   if (TimeCurrent() - g_datetime_424 >= 30) g_datetime_424 = TimeCurrent();
   return (0);
}
//|-----------------------------------------------------------------------------------------|
//|                                     C O M M E N T                                       |
//|-----------------------------------------------------------------------------------------|
string EaComment(string cmt="")
{
   string strtmp = cmt+"-->"+EaName+" "+EaVer+"<--";
//--- Assert Basic info in comment
   strtmp=strtmp+"\n";
   
//--- Assert additional comments here
   strtmp=TDComment(strtmp);
   strtmp=TurtleComment(strtmp);
   strtmp=GhostComment(strtmp);
   
   strtmp = strtmp+"\n";
   return(strtmp);
}
void EaDebugPrint(int dbg, string fn, string msg)
{
   static int noStackCount;
   if(EaViewDebug>=dbg)
   {
      if(dbg>=2 && EaViewDebugNoStack>0)
      {
         if( MathMod(noStackCount,EaViewDebugNoStack) <= EaViewDebugNoStackEnd )
            Print(EaViewDebug,"-",noStackCount,":",fn,"(): ",msg);
            
         noStackCount ++;
      }
      else
      {
         if(EaViewDebugNotify)   SendNotification( EaViewDebug + ":" + fn + "(): " + msg );
         Print(EaViewDebug,":",fn,"(): ",msg);
      }
   }
}
string EaDebugInt(string key, int val)
{
   return( StringConcatenate(";",key,"=",val) );
}
string EaDebugDbl(string key, double val, int dgt=5)
{
   return( StringConcatenate(";",key,"=",NormalizeDouble(val,dgt)) );
}
string EaDebugStr(string key, string val)
{
   return( StringConcatenate(";",key,"=\"",val,"\"") );
}
string EaDebugBln(string key, bool val)
{
   string valType;
   if( val )   valType="true";
   else        valType="false";
   return( StringConcatenate(";",key,"=",valType) );
}
//|------------------------------------------------------------------------------------------|
//|                       E N D   O F   E X P E R T   A D V I S O R                          |
//|------------------------------------------------------------------------------------------|